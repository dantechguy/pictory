Where to work:
- remove all 'rooms' intermediary methods, just use straight 'room'
- if all players /exit, will disconnect delete room twice?
- implement time limits
- check all routes check for correct state and ready
- is 50KB limit large enough for drawing data
- check every user input for potential failure
- lobby.html and other game state files
- style.css
- allow players to leave mid-game by pressing 'leave'
- client send constant PUT /data updates during timer (if input update)
- plan and do all client side stuff

Players leaving:
- players can exit & reload page anytime
- game will not change state until all players are connected and ready
  - if timer hits zero
    - non connected players have 30 seconds to connect before removed
    - non ready players are set to ready
- players can permanently leave game via leave button, for next round
  - will remove that player from the follow chain after next change
  - delete players data chain
  - connect new neighbours in chain
  - figure out how to re-sort chain, delete left players chain

RESTful API endpoints:
GET /
  - home page, where user joins initially
POST /join
  - request to join or create room
  - request body JSON {roomId: "1234", name: "dan"}
  - error
    - name invalid (3-8 letters)
    - name already taken
    - room id invalid (4 numbers)
    - room already started (not in lobby)
    - send JSON message {status: "error", data: "error message"} 401
  - success
    - name valid
    - room id valid
    - room id not started or created
    - name not taken
    - create room if needed
    - create user profile
    - create session id for profile
    - send JSON message {status: "success", data: ""} (changes cookie in headers) 200
GET /game
  - for all in game states
  - session id cookie
  - error
    - no cookie found
    - session id invalid
    - user socket already connected
    - delete cookie, return / 401
  - success
    - session id valid
    - user socket not connected
    - look at session id room
    - look at room state AND player ready state
    - send html file for state
GET /time
  - for client to display timer to end of state
  - session id cookie
  - error
    - no cookie
    - session id invalid
    - room in lobby or replay
    - send JSON message {status: "error", data: "[error message]"} 401
  - success
    - room not in lobby or replay (correct state)
    - session id valid
    - look at session id room
    - look at room timer
    - send JSON message {status: "success", data: "[UTC timestamp]"} 200
PUT /data
  - updating the text or drawing data you have made
  - request body JSON {data: "text prompt"} or {data: "[drawing data]"}
  - session id cookie
  - error
    - not within time limit
    - room in lobby or replay
    - player already ready
    - no cookie
    - session id invalid
    - send JSON message {status: "error", data: "[error message]"} 401
  - success
    - within time limit
    - room not in lobby or replay (correct state)
    - player not ready (hasn't send data yet)
    - session id valid
    - look at session id profile
    - set profile data to data
    - send JSON message {status: "success", data: ""} 200
GET /data
  - text or drawing data as your prompt
  - session id cookie
  - error
    - no cookie
    - session id invalid
    - in lobby state
    - send JSON message {status: "error", data: "[error message]"} 401
  - success
    - not in lobby state
    - session id valid
    - look at session id profile
    - room not in replay state
      - look at following profile
      - get following profile previous data
      - send JSON message {status: "success", data: "[following data]"} 200
    - room in replay state
      - game has ended
      - look at player profile
      - get chain data
      - send JSON message {status: "success", data: "[chain data]"} 200
PUT /done
  - update once you are ready to start the game
  - session id cookie
  - error
    - in replay state (game ended)
    - no cookie
    - session id invalid
    - send JSON message {status: "error", data: "[error message]"} 401
  - success
    - not in replay state (game still going)
    - session id valid
    - look at session id profile
    - set ready to true
    - send JSON message {status: "success", data: ""} 200
    - check if all players are ready
      - try next state
    - send players-ready update
POST /exit
  -

Next state steps:
- cancel previous timeouts
- remove all players who will exit (/exit, or not connected)
  - find all players not connected
  - locate an exit player
    - find index
    - set previous player 'following' to exit player 'following'
    - remove player from room
    - remove player from 'players'
- if state is lobby
  - assign follow chain
- move all player's new data into other player's chain
  - chain stores all sequential prompt data, starting with that players idea
  - if a player leaves, only their chain will be deleted
  - other players' drawings and prompts in that chain are deleted too
  - find target player's chain
    - add round number to index, modulo, and access
  - add data to target player's chain
- move all players new data to previous
- set all players not ready
- check if round number > max rounds
  - if not, still have rounds to play
    - round number ++
    - change to next state in cycle
    - update new Unix timestamp
    - set timeout to call-back for state timer (new round!), 'nextState' cancels timeout
  - if round number > max rounds
    - game over, set state to replay
- send reload web-socket message

- after time limit (someone not connected or ready), 'nextState' hasn't been called
- force nextState change
- switch all players to ready
- if all players connected
  - call tryToMoveToNextState method
- if not all players are connected
  - set timeout call-back for connect time, 'nextState' cancels timeout

- after second time limit, 'nextState' still hasn't been called
- someone not connecting, getting kicked
- find non connected players
- set 'exit' attribute to true
- call tryToMoveToNextState method

Web-socket interactions:
- Client:
    reload
      - game state has updated, reload page
    playersReady
      - updated when new players are ready or connected {"dan":{ready:true, connected:false}, "fed":{ready:true, connected:true}}
- Server:
    connected
      - connected at /game
      - just joined, changing state, or reloading
      - get session id cookie
      - if session id is valid
        - file profile for session id
        - add socket to profile
        - add socket to socket.io room
        - set 'connected' to true
        - if all players ready
          - try next state
    disconnected
      - disconnected from /game
      - changing page, reloading or leaving
      - get session id from cookie
      - remove socket from socket.io room
      - if session id is valid
        - find profile for session id
        - remove socket from profile
        - set 'connected' to false
        - if all players are disconnected
          - clear previous timeouts
          - delete room and players

Identifier and key rules:
  "name"
  "roomId"
  "sessionId"
  "data"

  Networking Rules:
  - only use web-sockets for direct server to client communication
  - all other data use HTTPS and RESTful API


Using REST API:
  request = putData(url, "whatever data")
  .then(successData) // this will be called with code 2xx and status success
  .catch(errorData); // network error, non 2xx code, or status error

  - return status codes are only used for browser
    the client uses the JSON status value for validation
