Networking Rules:
- only use web-sockets for direct server to client communication
- all other data use HTTPS and RESTful API

Where to work:
- web-socket updates
- game start routine
- check all routes check for correct state and ready
- is 50KB limit large enough for drawing data
- check every user input for potential failure
- lobby.html and other game state files
- style.css
- allow players to leave mid-game by pressing 'leave'
- after time limit, client send any data
- plan and do all client side stuff

Players leaving:
- players can exit & reload page anytime
- game will not change state until all players are connected and ready
  - if timer hits zero
    - non connected players have 30 seconds to connect before removed
    - non ready players are set to ready and data is sent
- players can permanently leave game via leave button, for next state
  - will remove that player from the follow chain after next change
  - connect new neighbours in chain
  - figure out how to re-sort chain, delete left players chain

RESTful API endpoints:
GET /
  - home page, where user joins initially
POST /join
  - request to join or create room
  - request body JSON {roomId: "1234", name: "dan"}
  - error
    - name invalid (3-8 letters)
    - name already taken
    - room id invalid (4 numbers)
    - room already started (not in lobby)
    - send JSON message {status: "error", data: "error message"} 401
  - success
    - name valid
    - room id valid
    - room id not started or created
    - name not taken
    - create room if needed
    - create user profile
    - create session id for profile
    - send JSON message {status: "success", data: ""} (changes cookie in headers) 200
GET /game
  - for all in game states
  - session id cookie
  - error
    - no cookie found
    - session id invalid
    - user socket already connected
    - delete cookie, return / 401
  - success
    - session id valid
    - user socket not connected
    - look at session id room
    - look at room state
    - send html file for state
GET /time
  - for client to display timer to end of state
  - session id cookie
  - error
    - no cookie
    - session id invalid
    - room in lobby
    - send JSON message {status: "error", data: "[error message]"} 401
  - success
    - room not in lobby (correct state)
    - session id valid
    - look at session id room
    - look at room timer
    - send JSON message {status: "success", data: "[UTC timestamp]"} 200
PUT /data
  - text or drawing data you have made
  - request body JSON {data: "text prompt"} or {data: "[drawing data]"}
  - session id cookie
  - error
    - room in lobby
    - player already ready
    - no cookie
    - session id invalid
    - send JSON message {status: "error", data: "[error message]"} 401
  - success
    - room not in lobby (correct state)
    - player not ready (hasn't send data yet)
    - session id valid
    - look at session id profile
    - set profile data to data
    - set profile ready to true
    - send JSON message {status: "success", data: ""} 200
GET /data
  - text or drawing data as your prompt
  - session id cookie
  - error
    - no cookie
    - session id invalid
    - in lobby state
    - send JSON message {status: "error", data: "[error message]"} 401
  - success
    - not in lobby state
    - session id valid
    - look at session id profile
    - look at following profile
    - get following profile data
    - send JSON message {status: "success", data: "[following data]"} 200
PUT /done
  - update once you are ready to start the game
  - session id cookie
  - error
    - not in lobby state (game already started)
    - no cookie
    - session id invalid
    - send JSON message {status: "error", data: "[error message]"} 401
  - success
    - game in lobby state (not started)
    - session id valid
    - look at session id profile
    - set ready to true
    - send JSON message {status: "success", data: ""} 200
    - check if all players are ready
      - start game
      - assign random follow chain
      - change state
      - send web-socket reload message
POST /exit
  -

Web-socket interactions:
- Client:
    reload
      - game state has updated, reload page
    playersReady
      - updated when new players are ready {"dan":true, "fed":false}
- Server:
    connected
      - connected at /game
      - just joined, changing state, or reloading
      - get session id cookie
      - file profile for session id
      - add socket to profile
      - add socket to socket.io room
      - set 'connected' to true
    disconnected
      - disconnected from /game
      - changing page, reloading or leaving
      - get session id from cookie
      - find profile for session id
      - remove socket from profile
      - remove socket from socket.io room
      - set 'connected' to false
      - if all players are disconnected
        - delete room and players

Identifier and key rules:
  "name"
  "roomId"
  "sessionId"

Using REST API:
  request = putData(url, "whatever data")
  .then(successData) // this will be called with code 2xx and status success
  .catch(errorData); // network error, non 2xx code, or status error

  - return status codes are only used for browser
    the client uses the JSON status value for validation
